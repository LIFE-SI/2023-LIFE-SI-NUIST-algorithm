# 实验4

## 1．实验目的

（1）熟悉动态规划算法

（2）理解动态规划算法求解问题的一般性过程

（3）针对特定问题，设计并编写动态规划程序

（4）能够分析动态规划算法的时间复杂度

## 2．实验内容题目描述

wzy在跑步，由于昨天下雨了，所以跑道上某些位置堆积了雨水。wzy并不希望自己踩到水坑，所以当他将要踩到水坑时候他会选择跳过去。具体的，跑道可以抽象为长度为n的序列，wzy从位置1出发，目的地是到达位置n。跑道上会有m个位置存在积水，他每次可以跳1到k单位长度正整数的距离，问wzy最少可以踩到几次水坑到达位置n。 

- 输入描述

> 输入第一行三个正整数n，m，k，分别代表路径的长度，积水的个数以及wzy一次最远可以跨多远。第二行共m个正整数ai，分别代表第i个水坑的位置。 

- 输出描述

> 输出共一行，一个正整数，表示wzy至少踩到几次水坑才能到达位置n。 

- 样例输入

> 6 3 2
>
> 2 3 5 

- 样例输出

> 1

## 3．算法实现和实验结果

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=10005;
int dp[maxn],a[maxn];
int n,m,k;
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		int temp;
		cin>>temp;
		a[temp]=1;
	}
	dp[1]=a[1];
	for(int i=2;i<=n;i++)
	{
		dp[i]=dp[i-1]+a[i];
		for(int j=1;j<=k&&i-j>=1;j++)
		{
			dp[i]=min(dp[i],dp[i-j]+a[i]);
		}
	}
	cout<<dp[n]<<endl;
	return 0;
}
```

![image](https://user-images.githubusercontent.com/95600943/236154429-40184f78-8b37-48c2-a385-9071578b41e3.png)

## 4．分析与讨论（算法时间复杂度分析和讨论）

对于每一次跳跃到的位置,都可以由前一次的跳跃到的位置和步长决定;踩到的水坑个数由跳跃到前一次位置所踩的水坑个数加上本次跳跃到位置的状态决定,可以考虑使用动态规划解决.

一维数组a标记水坑位置(0表示无,1表示有),建立一维 $dp$ 数组,则 $dp[i]=min(dp[i-1],dp[i-j])+a[i],1<=j<=k$ , $dp[n]$ 即为最优解,使得到达终点踩到的水坑数最少.

对于到达终点过程中每一个可以到达的位置, $dp$ 数组的状态转移次数为步长 $k$ ,一共有 $n$ 个位置可达,则时间复杂度为 $O(n*k)$ .
 
