# 实验3

## 1．实验目的

（1）熟悉贪心算法的基本设计原理

（2）理解基于贪心思想的问题求解过程

（3）编写能够实现贪心算法的程序

（4）能够证明贪心算法的正确性并分析贪心算法的时间复杂度

## 2．实验内容题目描述

小伟报名参加中央电视台的智力大冲浪节目。本次挑战赛吸引了众多参赛者，主持人为了表彰大家的勇气，先奖励每个参赛者 m 元。先不要太高兴！因为这些钱还不一定都是你的？！接下来主持人宣布了比赛规则：首先，比赛时间分为 n 个时段 (n≤500)，它又给出了很多小游戏，每个小游戏都必须在规定期限 ti 前完成 (1≤ti≤n)。如果一个游戏没能在规定期限前完成，则要从奖励费 m 元中扣去一部分钱 wi，wi为自然数，不同的游戏扣去的钱是不一样的。当然，每个游戏本身都很简单，保证每个参赛者都能在一个时段内完成，而且都必须从整时段开始。主持人只是想考考每个参赛者如何安排组织自己做游戏的顺序。作为参赛者，小伟很想赢得冠军，当然更想赢取最多的钱！注意：比赛绝对不会让参赛者赔钱！ 

- 输入描述

> 多组输入，每组共 4 行，第 1 行为 m，表示一开始奖励给每位参赛者的钱；第 2 行为 n，表示有 n 个小游戏；第 3 行有 n 个数，分别表示游戏 1 到 n 的规定完成期限；第 4 行有 n 个数，分别表示游戏 1 到 n 不能在规定期限前完成的扣款数。 

- 输出描述

>对于每组输入，仅 1 行，表示小伟能赢取最多的钱 

- 样例输入

> 10000
>7
>4 2 4 3 1 4 6
> 70 60 50 40 30 20 10 

- 样例输出

> 9950

## 3．算法实现和实验结果

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=505;
struct node
{
    int t,v;    
}a[maxn];

bool cmp(node a,node b)
{
    return a.v>b.v;
}
int sign[maxn];
int m,n;
int main()
{
    while(cin>>m>>n)
    {
        int s=0;
        memset(sign,0,sizeof(sign));
        for(int i=1;i<=n;i++)
            cin>>a[i].t;
        for(int i=1;i<=n;i++)
        {
            cin>>a[i].v;
            s=s+a[i].v;
        }
        sort(a+1,a+n+1,cmp);
        for(int i=1;i<=n;i++)
        {
            while(a[i].t--)
            {
                if(sign[a[i].t]==0)
                {
                    sign[a[i].t]=1;
                    s=s-a[i].v;
                    break;
                }
            }
        }
        cout<<m-s<<endl;
    }
    return 0;
}
```

![img](https://p.ananas.chaoxing.com/star3/origin/4858819b4239031e956a6690cb5ac044.png) 

## 4．分析与讨论（贪心算法正确性证明，算法时间复杂度分析和讨论）

首先，先完成会罚款高的游戏明显明显更有益（时间消耗相同）；其次，要先处理罚款大的项，而又尽量不影响后面的游戏，只能将这个游戏放在规定最晚完成的时间段0-t的最后面t来做，若已经有游戏占用，就继续考虑t-1，直到0，如果没有对它的安排，则放弃。最后，将放弃的游戏的罚款减去，即为所求解。    先将价格从大到小排序，把任务在范围内从后往前按排，尽量减少冲突，留下更多空间，按顺序寻找这个游戏最迟能到什么时候完成，标记这个时间段，表示这个时间段已经被占用了；如果在后续发现此时间段不能完成，就放弃这个游戏。    时间复杂度为O(n^2)。 