# 实验1

## 1．实验目的

（1）熟悉搜索算法 

（2）理解基于搜索的问题求解的一般过程 

（3）编写能够实现DFS的搜索程序 

（4）能够分析DFS基本算法的时间复杂 

## 2．实验内容 

题目描述

> 国际象棋的棋盘可以看做是一个 8 × 8 的矩阵，上面每一个格子仅能放一枚棋子，现在给出一个 8 × 8 的由 0 和 1 组成的矩阵，代表象棋棋盘，1 代表当前位置放置了一个皇后，0 则代表什么都没有放，上面有 n（n 为小于 8 的正整数）个位置已经放上了皇后棋子（相互之间不冲突，合理摆放），现在另外给你 8 - n 个皇后，问你有多少合理的摆法。 

输入描述

> 一个 8 × 8 的由 0 和 1 组成的矩阵。

输出描述

> 一个整数，为摆放的种类数。

样例输入

> 1 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 0

输出样例

> 4

## 3. 算法实现和实验结果

```C++
#include<bits/stdc++.h>
using namespace std;
int a[10][10];
int cnt = 0;
int safe (int x, int y) //判断此位置（x，y）是否安全，能否放置棋子
{
 	int i,j;
  	for(i = 1; i<=8; i++)
  	{
		if(a[i][y]==1)
			return 0;
	}
  	for(i=1; i<=8; i++)=
  	{
		for(j=1; j<=8; j++)
		{
     		if(abs(x-i)==abs(y-j) && a[i][j]==1)
       			return 0;
    	}  
  	}
  	return 1;
}

void dfs(int v) // dfs搜索遍历
{
  	if(v > 8)
  	{
    	cnt ++;
    	return ;
  	}
  	int flag = 1;
  	int j;
  	for(j=1;j<=8;j++)
  	{
    	if(a[v][j]==1)
   		{
      		flag = 0;
    		break;
    	}
  	}
  	if (flag == 1)
  	{
    	for(j=1;j<=8;j++)
   		{
     		if(safe(v,j))
     		{
       			a[v][j] = 1;
       			dfs(v+1);
        		a[v][j] = 0; //进行回溯
     		}
    	}
  	}
  	else
  	{
      dfs(v+1);
  	}
}

int main ()
{
    int i,j;
    for(i=1;i<=8;i++)
        for(j=1;j<=8;j++)
        	cin>>a[i][j];
    dfs(1);//从第一个格子开始搜索遍历
    cout<<cnt<<endl;
    return 0;
}
```

结果：

![img](https://p.ananas.chaoxing.com/star3/origin/76da8fa149d11a33c6f620d5cc0eed20.png)

## 4．分析与讨论（算法时间复杂度分析和讨论）

算法时间复杂度分析和讨论：

由于同行互斥，所以从第一行开始进行搜素。如果此位置未放置初始棋子并且可放置棋子（同行同列同对角不会影响此位置），则放置棋子（进行标记），进入下一行，重复进行之前的搜索（进行递归），当查找到一种情况后，进行回溯。

时间复杂度取决于搜索的深度和每个节点的扩展次数。

普遍地，假设棋盘大小为$n*n$，初始未放置棋子，则进入每一行进行搜索时需要遍历$n$次，进入下一行后，同样需要遍历$n$次，时间复杂度为$O(n^n)$。

在这个问题中，每个节点最多可以扩展8次，因为每行只能有一个皇后。搜索的深度最多为8，因为只有8个皇后。因此，时间复杂度为$O(8^8)$，这是一个非常小的数字，因此这个算法是有效的。

---

2023.04.01 @ TRUSTWSXNH@outlook.com

